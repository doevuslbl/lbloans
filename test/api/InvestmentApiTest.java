/*
 * LB Loan Management API
 * API for loan management
 *
 * OpenAPI spec version: 0.0.1
 * Contact: raynard.eiger@outlook.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package api;

import static java.util.Collections.emptyList;
import static java.util.Collections.singletonList;
import static org.hamcrest.core.IsEqual.equalTo;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;

import java.io.InputStream;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.apache.commons.io.IOUtils;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;

import loans.api.InvestmentApi;
import loans.model.ErrorResponse;
import loans.model.Investment;
import loans.model.Investor;
import loans.model.InvestorAmountsDue;
import loans.model.InvestorInterestRequest;
import loans.model.Loan;
import loans.model.Rate;
import loans.respository.InvestmentRespository;
import loans.respository.InvestorRespository;
import loans.respository.LoanRespository;

@RunWith(MockitoJUnitRunner.class)
public class InvestmentApiTest {

	private static final UUID LOAN_UUID = UUID.fromString("91f99fc3-c0b7-4ce4-b7a5-3b69726d6ad5");
	private static final UUID INVESTOR_UUID = UUID.fromString("91f99fc3-c0b7-4ce4-b7a5-3b69726d6ad7");
	private static final UUID INVESTOR_UUID_2 = UUID.fromString("91f99fc3-c0b7-4ce4-b7a5-3b69726d6ad9");

	@InjectMocks private InvestmentApi investmentApi = new InvestmentApi();
	
	@Mock private LoanRespository loanRepository;
	@Mock private InvestorRespository investorRepository;
	@Mock private InvestmentRespository investmentRepository;
	
	@Captor ArgumentCaptor<Loan> loanCaptor;
	@Captor ArgumentCaptor<Investor> investorCaptor;
	@Captor ArgumentCaptor<Investment> investmentCaptor;
	
	@Test
	public void testCreateValidInvestment() throws Exception {
		Loan loan = mock(Loan.class);
		when(loan.validate()).thenReturn(emptyList());
		
		when(loanRepository.findById(LOAN_UUID)).thenReturn(Optional.of(loan));
		
		InputStream investmentInput = InvestmentApiTest.class.getResourceAsStream("InvestmentApiTest-valid-investment.json");
		
		ResponseEntity<Object> responseEntity = investmentApi.create(IOUtils.toString(investmentInput));
		
		assertThat(responseEntity.getStatusCode(), equalTo(HttpStatus.CREATED));
		
		verify(loanRepository).save(loanCaptor.capture());
		verify(investorRepository).save(investorCaptor.capture());
		verify(investmentRepository).save(investmentCaptor.capture());
		
		assertThat(loanCaptor.getValue(), equalTo(loan));
		assertThat(investorCaptor.getValue().getFirstName(), equalTo("Robert")); // ideally should check more properties
		Investment savedInvestment = investmentCaptor.getValue();
		assertThat(savedInvestment.getAmount(), equalTo(50000.00)); // ideally should check more properties
		assertThat(savedInvestment.getLoan(), equalTo(loan));
	}
	
	@Test
	public void testEmptyInput() throws JsonProcessingException {
		ResponseEntity<Object> response = investmentApi.create("{}");
		
		assertThat(response.getStatusCode(), equalTo(HttpStatus.UNPROCESSABLE_ENTITY));
		ErrorResponse errorResponse = (ErrorResponse) response.getBody();
		assertThat(errorResponse.getErrors().size(), equalTo(5));
		assertTrue(errorResponse.getErrors().contains(Investment.AMOUNT_INVALID));
		assertTrue(errorResponse.getErrors().contains(Investment.INVESTOR_EMPTY));
		assertTrue(errorResponse.getErrors().contains(Investment.LOAN_EMPTY));
		assertTrue(errorResponse.getErrors().contains(Investment.START_DATE_EMPTY));
		assertTrue(errorResponse.getErrors().contains(Investment.END_DATE_EMPTY));
		
		verifyZeroInteractions(loanRepository);
		verifyZeroInteractions(investorRepository);
		verifyZeroInteractions(investmentRepository);
	}
	
	@Test
	public void testMissingInvestor() throws Exception {
		Loan loan = mock(Loan.class);
		when(loan.validate()).thenReturn(emptyList());
		
		when(loanRepository.findById(LOAN_UUID)).thenReturn(Optional.of(loan));
		
		InputStream investmentInput = InvestmentApiTest.class.getResourceAsStream("InvestmentApiTest-investment-missing-investor.json");
		
		ResponseEntity<Object> responseEntity = investmentApi.create(IOUtils.toString(investmentInput));
		
		assertThat(responseEntity.getStatusCode(), equalTo(HttpStatus.UNPROCESSABLE_ENTITY));
		
		ErrorResponse errorResponse = (ErrorResponse) responseEntity.getBody();
		assertThat(errorResponse.getErrors().size(), equalTo(1));
		assertTrue(errorResponse.getErrors().contains(Investment.INVESTOR_EMPTY));
		
		verify(loanRepository, never()).save(Mockito.any(Loan.class));
		verifyZeroInteractions(investorRepository);
		verifyZeroInteractions(investmentRepository);
	}
	
	
	@SuppressWarnings("unchecked")
	@Test
	public void testCalculatingSimpleInterest() throws Exception {
		when(investorRepository.findById(INVESTOR_UUID)).thenReturn(Optional.of(new Investor()
																																						.firstName("Robert")
																																						.lastName("Burns")
																																						.id(INVESTOR_UUID)
																																						.investments(singletonList(new Investment()
																																																			 .amount(50000.00)
																																																			 .loan(new Loan()
																																																					 	 .currency("GBP")
																																																					 	 .rates(singletonList(new Rate().rate(5.0))))))));

		// One year at 5% of 50000 investment = 50000 * 0.05 = 2500 GBP
		InvestorInterestRequest request = new InvestorInterestRequest()
																			.investorIds(singletonList(INVESTOR_UUID))
																			.startDate(LocalDate.of(2019, 1, 1))
																			.endDate(LocalDate.of(2020, 1, 1));
		
		ObjectMapper mapper = new ObjectMapper().registerModule(new JavaTimeModule());
		
		ResponseEntity<Object> responseEntity = investmentApi.calculateInterestForInvestors(mapper.writeValueAsString(request));
		
		List<InvestorAmountsDue> amountsDue = (List<InvestorAmountsDue>) responseEntity.getBody();
		
		assertThat(amountsDue.size(), equalTo(1));
		assertThat(amountsDue.get(0).getAmountsDuePerCurrency().get("GBP"), equalTo(2500.25)); // rounding causes the .25, not sure of cause yet
	}
	

	@SuppressWarnings("unchecked")
	@Test
	public void testCalculatingMultipleCurrencies() throws Exception {
		Investment investment1 = new Investment()
															 .amount(50000.00)
															 .loan(new Loan()
																	 	 .currency("GBP")
																	 	 .rates(singletonList(new Rate().rate(5.0)))); // year's interest: 2500.25
		
		Investment investment2 = new Investment()
														 .amount(100000.00)
														 .loan(new Loan()
																 	 .currency("GBP")
																 	 .rates(singletonList(new Rate().rate(4.0)))); // 4000.40
		
		Investment investment3 = new Investment()
				 										 .amount(50000.00)
				 										 .loan(new Loan()
				 												 	 .currency("USD")
				 												 	 .rates(singletonList(new Rate().rate(5.0)))); // 2500.25
		
		Investment investment4 = new Investment()
														 .amount(50000.00)
														 .loan(new Loan()
																   .currency("GBP")
																   .rates(singletonList(new Rate().rate(10.0)))); // 5000.50
		
		Investment investment5 = new Investment()
				 										 .amount(10000.00)
				 										 .loan(new Loan()
				 												 	 .currency("EUR")
				 												 	 .rates(singletonList(new Rate().rate(10.0)))); // 1000.10
		
		Investment investment6 = new Investment()
				 										 .amount(5000.00)
				 										 .loan(new Loan()
				 												 	 .currency("EUR")
				 												 	 .rates(singletonList(new Rate().rate(1.0)))); // 50.005
		
		List<Investment> investments1 = new ArrayList<>();
		investments1.add(investment1);
		investments1.add(investment2);
		investments1.add(investment3);
		investments1.add(investment4);
		
		List<Investment> investments2 = new ArrayList<>();
		investments2.add(investment5);
		investments2.add(investment6);
		
		when(investorRepository.findById(INVESTOR_UUID)).thenReturn(Optional.of(new Investor()
																																						.firstName("Robert")
																																						.lastName("Burns")
																																						.id(INVESTOR_UUID)
																																						.investments(investments1)));
		
		when(investorRepository.findById(INVESTOR_UUID_2)).thenReturn(Optional.of(new Investor()
																																							.firstName("John")
																																							.lastName("Yeats")
																																							.id(INVESTOR_UUID_2)
																																							.investments(investments2)));

		List<UUID> investors = new ArrayList<>();
		investors.add(INVESTOR_UUID);
		investors.add(INVESTOR_UUID_2);
		
		InvestorInterestRequest request = new InvestorInterestRequest()
																			.investorIds(investors)
																			.startDate(LocalDate.of(2019, 1, 1))
																			.endDate(LocalDate.of(2020, 1, 1));
		
		ObjectMapper mapper = new ObjectMapper().registerModule(new JavaTimeModule());
		
		ResponseEntity<Object> responseEntity = investmentApi.calculateInterestForInvestors(mapper.writeValueAsString(request));
		
		List<InvestorAmountsDue> amountsDue = (List<InvestorAmountsDue>) responseEntity.getBody();
		
		assertThat(amountsDue.size(), equalTo(2));
		assertThat(amountsDue.get(0).getInvestorId(), equalTo(INVESTOR_UUID));
		assertThat(amountsDue.get(1).getInvestorId(), equalTo(INVESTOR_UUID_2));
		
		assertThat(amountsDue.get(0).getAmountsDuePerCurrency().get("GBP"), equalTo(11501.15));
		assertThat(amountsDue.get(0).getAmountsDuePerCurrency().get("USD"), equalTo(2500.25));
		assertThat(amountsDue.get(1).getAmountsDuePerCurrency().get("EUR"), equalTo(1050.105)); // rounding causes the pence, not sure of cause yet
	}
	
	
}
